generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model admin_actions {
  id          String   @id
  user_id     String
  action      String
  target_type String
  target_id   String
  metadata    Json?
  created_at  DateTime @default(now())
  users       users    @relation(fields: [user_id], references: [id])

  @@index([target_type, target_id])
  @@index([user_id, created_at])
}

model prompt_edits {
  id                                             String       @id
  prompt_id                                      String
  title                                          String
  prompt_text                                    String
  description                                    String?
  example_output                                 String?
  category                                       String
  change_description                             String
  suggested_by_name                              String
  suggested_by_user_id                           String?
  status                                         ReviewStatus @default(PENDING)
  rejection_reason                               String?
  created_at                                     DateTime     @default(now())
  reviewed_at                                    DateTime?
  reviewed_by_user_id                            String?
  prompts                                        prompts      @relation(fields: [prompt_id], references: [id], onDelete: Cascade)
  users_prompt_edits_reviewed_by_user_idTousers  users?       @relation("prompt_edits_reviewed_by_user_idTousers", fields: [reviewed_by_user_id], references: [id])
  users_prompt_edits_suggested_by_user_idTousers users?       @relation("prompt_edits_suggested_by_user_idTousers", fields: [suggested_by_user_id], references: [id])

  @@index([prompt_id, status])
}

model prompt_tags {
  prompt_id String
  tag_id    String
  prompts   prompts @relation(fields: [prompt_id], references: [id], onDelete: Cascade)
  tags      tags    @relation(fields: [tag_id], references: [id], onDelete: Cascade)

  @@id([prompt_id, tag_id])
}

model prompts {
  id                                        String         @id
  slug                                      String         @unique
  title                                     String
  prompt_text                               String
  description                               String?
  example_output                            String?
  category                                  String
  author_name                               String
  author_url                                String?
  submitted_by_user_id                      String?
  status                                    PromptStatus   @default(PENDING)
  rejection_reason                          String?
  featured                                  Boolean        @default(false)
  view_count                                Int            @default(0)
  copy_count                                Int            @default(0)
  created_at                                DateTime       @default(now())
  updated_at                                DateTime
  approved_at                               DateTime?
  approved_by_user_id                       String?
  deleted_at                                DateTime?
  prompt_edits                              prompt_edits[]
  prompt_tags                               prompt_tags[]
  users_prompts_approved_by_user_idTousers  users?         @relation("prompts_approved_by_user_idTousers", fields: [approved_by_user_id], references: [id])
  users_prompts_submitted_by_user_idTousers users?         @relation("prompts_submitted_by_user_idTousers", fields: [submitted_by_user_id], references: [id])

  @@index([slug])
  @@index([status, created_at])
  @@index([status, featured, approved_at])
}

model tags {
  id          String        @id
  name        String        @unique
  slug        String        @unique
  usage_count Int           @default(0)
  created_at  DateTime      @default(now())
  prompt_tags prompt_tags[]

  @@index([slug])
}

model users {
  id                                                    String          @id
  email                                                 String          @unique
  name                                                  String?
  image                                                 String?
  is_admin                                              Boolean         @default(false)
  created_at                                            DateTime        @default(now())
  last_login_at                                         DateTime?
  admin_actions                                         admin_actions[]
  prompt_edits_prompt_edits_reviewed_by_user_idTousers  prompt_edits[]  @relation("prompt_edits_reviewed_by_user_idTousers")
  prompt_edits_prompt_edits_suggested_by_user_idTousers prompt_edits[]  @relation("prompt_edits_suggested_by_user_idTousers")
  prompts_prompts_approved_by_user_idTousers            prompts[]       @relation("prompts_approved_by_user_idTousers")
  prompts_prompts_submitted_by_user_idTousers           prompts[]       @relation("prompts_submitted_by_user_idTousers")
  accounts                                              Account[]
  sessions                                              Session[]
}

enum PromptStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

// NextAuth.js Models
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user users @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         users    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}
